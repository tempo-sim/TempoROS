#!/usr/bin/env bash
# Copyright Tempo Simulation, LLC. All Rights Reserved

set -e

PROJECT_ROOT="${1//\\//}"

# Check for jq
if ! which jq &> /dev/null; then
  echo "Couldn't find jq"
  if [[ "$OSTYPE" = "msys" ]]; then
    echo "Install (on Windows): curl -L -o /usr/bin/jq.exe https://github.com/stedolan/jq/releases/latest/download/jq-win64.exe)"
  elif [[ "$OSTYPE" = "darwin"* ]]; then
    echo "Install (on Mac): brew install jq"
  elif [[ "$OSTYPE" = "linux-gnu"* ]]; then
    echo "Install (on Linux): sudo apt-get install jq"
  fi
  exit 1
fi

# The temp directory where we will store the generated code, instead of just copying it directly to the source
# folder, thereby avoiding copying files that have not changed and triggering unnecessary rebuilds.
TEMP=$(mktemp -d)
GEN_TEMP_DIR="$TEMP/Generated"
mkdir -p "$GEN_TEMP_DIR"

TEMPOROS_BP_KEYWORD="TempoROS__BPSupport"

BP_LIBRARY_TEMPLATE=\
"// Copyright Tempo Simulation, LLC. All Rights Reserved

/* This file was generated by a TempoROS prebuild step and should not be modified. */

#pragma once
__INCLUDES__

#include \"TempoROSNode.h\"

#include \"TempoROSTypes.h\"

#include \"Kismet/BlueprintFunctionLibrary.h\"

#include \"__MODULENAME__TempoROSBlueprintFunctionLibrary.generated.h\"
__DELEGATES__

UCLASS(BlueprintType)
class __MODULEAPI__ U__MODULENAME__TempoROSBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()
__METHODS__
};
"

BP_INCLUDE_TEMPLATE=\
"
#include \"__INCLUDEFILE__\"
"

BP_PUBLISHER_TEMPLATE=\
"
    UFUNCTION(BlueprintCallable, Category = \"TempoROS\", meta=(AutoCreateRefTerm=\"QOSProfile\"))
    static void Add__SANITIZEDMESSAGETYPE__Publisher(UTempoROSNode* Node, const FString& Topic, const FROSQOSProfile& QOSProfile=FROSQOSProfile(), bool bPrependNodeName=true)
    {
        Node->AddPublisher<__MESSAGETYPE__>(Topic, QOSProfile, bPrependNodeName);
    }

    UFUNCTION(BlueprintCallable, Category = \"TempoROS\")
    static void Publish__SANITIZEDMESSAGETYPE__(UTempoROSNode* Node, const FString& Topic, const __MESSAGETYPE__& Message)
    {
        Node->Publish<__MESSAGETYPE__>(Topic, Message);
    }
"

BP_DELEGATE_TEMPLATE=\
"
DECLARE_DYNAMIC_DELEGATE_OneParam(FTempoROS__SANITIZEDMESSAGETYPE__Received, __MESSAGETYPE__, Value);
"

BP_SUBSCRIPTION_TEMPLATE=\
"
    UFUNCTION(BlueprintCallable, Category = "TempoROS")
    static void Add__SANITIZEDMESSAGETYPE__Subscription(UTempoROSNode* Node, const FString& Topic, const FTempoROS__SANITIZEDMESSAGETYPE__Received& TempoROSMessageReceivedEvent)
    {
        Node->AddSubscription<__MESSAGETYPE__>(Topic, TROSSubscriptionDelegate<__MESSAGETYPE__>::CreateLambda([TempoROSMessageReceivedEvent](const __MESSAGETYPE__& Value)
        {
            TempoROSMessageReceivedEvent.ExecuteIfBound(Value);
        }));
    }
"

# Function to refresh stale files
REPLACE_IF_STALE () {
  local FRESH="$1"
  local POSSIBLY_STALE="$2"

  if [ ! -f "$POSSIBLY_STALE" ]; then
    mkdir -p "$(dirname "$POSSIBLY_STALE")"
    cp -p "$FRESH" "$POSSIBLY_STALE"
  else
    if ! diff --brief "$FRESH" "$POSSIBLY_STALE" > /dev/null 2>&1; then
      cp -f "$FRESH" "$POSSIBLY_STALE"
    fi
  fi
}

REMOVE_IF_EXISTS() {
  TO_REMOVE=$1
  if [ -f "$TO_REMOVE" ]; then
    rm -rf "$TO_REMOVE"
  fi
}

echo "Generating ROS IDL BP Support..."

SANITIZE_UNREAL_TYPE() {
    local INPUT="$1"
    if [[ $INPUT =~ ^[UFA][A-Z] ]]; then
        echo "${INPUT:1}"
    else
        echo "$INPUT"
    fi
}

GEN_MODULE_BP() {
  local MODULE_NAME=$1
  local MODULE_PATH=$2
  local INCLUDE_FILES=""
  local LIBRARY_CONTENTS
  local LIBRARY_FILENAME=$MODULE_NAME"TempoROSBlueprintFunctionLibrary.h"
  mkdir -p "$GEN_TEMP_DIR/$MODULE_NAME"
  local LIBRARY_FILE="$GEN_TEMP_DIR/$MODULE_NAME/$LIBRARY_FILENAME"
  local PUBLISHER_LINES
  local SUBSCRIPTION_LINES
  if [ ! -d "$MODULE_PATH/Public" ]; then
    REMOVE_IF_EXISTS "$MODULE_PATH/Public/$LIBRARY_FILENAME"
    return
  fi
  for HEADER_FILE in $(find "$MODULE_PATH/Public" -name '*.h' -type f); do
    set +e
    local BP_SUPPORT_LINES=""
    local NEW_PUBLISHER_LINES=""
    local NEW_SUBSCRIPTION_LINES=""
    BP_SUPPORT_LINES=$(grep "$TEMPOROS_BP_KEYWORD" < "$HEADER_FILE")
    if [ "$BP_SUPPORT_LINES" != "" ]; then
      NEW_PUBLISHER_LINES=$(echo "$BP_SUPPORT_LINES" | grep TToROSConverter)
      if [ "$NEW_PUBLISHER_LINES" != "" ]; then
        PUBLISHER_LINES="$PUBLISHER_LINES\n$NEW_PUBLISHER_LINES"
      fi
      NEW_SUBSCRIPTION_LINES=$(echo "$BP_SUPPORT_LINES" | grep TFromROSConverter)
      if [ "$NEW_SUBSCRIPTION_LINES" != "" ]; then
        SUBSCRIPTION_LINES="$SUBSCRIPTION_LINES\n$NEW_SUBSCRIPTION_LINES"
      fi
    fi
    set -e
    if [ "$NEW_PUBLISHER_LINES" != "" ] || [ "$NEW_SUBSCRIPTION_LINES" != "" ]; then
      RELATIVE_PATH="${HEADER_FILE#$MODULE_PATH/Public/}"
      INCLUDE_FILES="$INCLUDE_FILES $RELATIVE_PATH"
    fi
  done
    
  if [ "$INCLUDE_FILES" = "" ]; then
    # Nothing to generate for this module
    REMOVE_IF_EXISTS "$MODULE_PATH/Public/$LIBRARY_FILENAME"
    return
  fi
      
  # Proceed with the generation
  LIBRARY_CONTENTS="$BP_LIBRARY_TEMPLATE"
  LIBRARY_CONTENTS=${LIBRARY_CONTENTS//__MODULENAME__/$MODULE_NAME}
  MODULE_API=$(echo "$MODULE_NAME"_API | tr '[:lower:]' '[:upper:]')
  LIBRARY_CONTENTS=${LIBRARY_CONTENTS//__MODULEAPI__/$MODULE_API}
  for INCLUDE_FILE in $INCLUDE_FILES; do
    INCLUDE_CONTENT=${BP_INCLUDE_TEMPLATE//__INCLUDEFILE__/$INCLUDE_FILE}
    LIBRARY_CONTENTS=${LIBRARY_CONTENTS//__INCLUDES__/$INCLUDE_CONTENT"__INCLUDES__"}
  done
  OLDIFS=$IFS
  IFS=$'\n'
  for PUBLISHER_LINE in $PUBLISHER_LINES; do
    local MESSAGE_TYPE
    local SANITIZED_MESSAGE_TYPE
    MESSAGE_TYPE=$(echo "$PUBLISHER_LINE" | sed -n 's/[^<]*<\([^>]*\)>.*/\1/p')
    SANITIZED_MESSAGE_TYPE=$(SANITIZE_UNREAL_TYPE "$MESSAGE_TYPE")
    PUBLISHER_CONTENT=${BP_PUBLISHER_TEMPLATE//__MESSAGETYPE__/$MESSAGE_TYPE}
    PUBLISHER_CONTENT=${PUBLISHER_CONTENT//__SANITIZEDMESSAGETYPE__/$SANITIZED_MESSAGE_TYPE}
    LIBRARY_CONTENTS=${LIBRARY_CONTENTS//__METHODS__/$PUBLISHER_CONTENT"__METHODS__"}
  done
  for SUBSCRIPTION_LINE in $SUBSCRIPTION_LINES; do
    local MESSAGE_TYPE
    local SANITIZED_MESSAGE_TYPE
    MESSAGE_TYPE=$(echo "$SUBSCRIPTION_LINE" | sed -n 's/[^<]*<\([^>]*\)>.*/\1/p')
    SANITIZED_MESSAGE_TYPE=$(SANITIZE_UNREAL_TYPE "$MESSAGE_TYPE")
    DELEGATE_CONTENT=${BP_DELEGATE_TEMPLATE//__MESSAGETYPE__/$MESSAGE_TYPE}
    DELEGATE_CONTENT=${DELEGATE_CONTENT//__SANITIZEDMESSAGETYPE__/$SANITIZED_MESSAGE_TYPE}
    LIBRARY_CONTENTS=${LIBRARY_CONTENTS//__DELEGATES__/$DELEGATE_CONTENT"__DELEGATES__"}
    SUBSCRIPTION_CONTENT=${BP_SUBSCRIPTION_TEMPLATE//__MESSAGETYPE__/$MESSAGE_TYPE}
    SUBSCRIPTION_CONTENT=${SUBSCRIPTION_CONTENT//__SANITIZEDMESSAGETYPE__/$SANITIZED_MESSAGE_TYPE}
    LIBRARY_CONTENTS=${LIBRARY_CONTENTS//__METHODS__/$SUBSCRIPTION_CONTENT"__METHODS__"}
  done
  IFS=$OLDIFS
  
  # Now that replacement is complete, remove all placeholders
  LIBRARY_CONTENTS=$(echo "$LIBRARY_CONTENTS" | sed "/__INCLUDES__/d")
  LIBRARY_CONTENTS=$(echo "$LIBRARY_CONTENTS" | sed "/__DELEGATES__/d")
  LIBRARY_CONTENTS=$(echo "$LIBRARY_CONTENTS" | sed "/__METHODS__/d")
  echo "$LIBRARY_CONTENTS" > "$LIBRARY_FILE"
  REPLACE_IF_STALE "$LIBRARY_FILE" "$MODULE_PATH/Public/$LIBRARY_FILENAME"
}

for BUILD_CS_FILE in $(find "$PROJECT_ROOT" -name '*.Build.cs' -type f); do
  BUILD_CS_FILENAME="$(basename "$BUILD_CS_FILE")"
  MODULE_NAME="${BUILD_CS_FILENAME%%.*}"
  MODULE_PATH="$(dirname "$BUILD_CS_FILE")"
  GEN_MODULE_BP "$MODULE_NAME" "$MODULE_PATH"
done

rm -rf "$TEMP"

echo "Done"
